[{"func_name": "Generator", "ret_type": "Generator", "signature": {"device": {"description": "the desired device for the generator.", "type": "Arguments"}}, "module": "torch"}, {"func_name": "_assert_async", "ret_type": "void", "signature": {"tensor": {"description": "a one element tensor to test to see if it is nonzero.  Zero", "type": "Args"}}, "module": "torch"}, {"func_name": "_check", "ret_type": null, "signature": {"cond": {"description": "If False, throw error", "type": "Args"}, "message": {"description": "Callable that returns either a string or", "type": "Args"}}, "module": "torch"}, {"func_name": "_check_index", "ret_type": null, "signature": {"cond": {"description": "If False, throw error", "type": "Args"}, "message": {"description": "Callable that returns either a string or", "type": "Args"}}, "module": "torch"}, {"func_name": "_check_not_implemented", "ret_type": null, "signature": {"cond": {"description": "If False, throw error", "type": "Args"}, "message": {"description": "Callable that returns either a string or", "type": "Args"}}, "module": "torch"}, {"func_name": "_check_tensor_all", "ret_type": null, "signature": {"cond": {"description": "Tensor of dtype ``torch.bool``. If any", "type": "Args"}, "message": {"description": "Callable that returns either a string or", "type": "Args"}}, "module": "torch"}, {"func_name": "_check_type", "ret_type": null, "signature": {"cond": {"description": "If False, throw error", "type": "Args"}, "message": {"description": "Callable that returns either a string or", "type": "Args"}}, "module": "torch"}, {"func_name": "_check_value", "ret_type": null, "signature": {"cond": {"description": "If False, throw error", "type": "Args"}, "message": {"description": "Callable that returns either a string or", "type": "Args"}}, "module": "torch"}, {"func_name": "abs", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "acos", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "acosh", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "add", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the tensor or number to add to :attr:`input`.", "type": "Args"}, "alpha": {"description": "the multiplier for :attr:`other`.", "type": "Keyword arguments"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "addbmm", "ret_type": "Tensor", "signature": {"batch1": {"description": "the first batch of matrices to be multiplied", "type": "Args"}, "batch2": {"description": "the second batch of matrices to be multiplied", "type": "Args"}, "beta": {"description": "multiplier for :attr:`input` (:math:`\\beta`)", "type": "Keyword args"}, "input": {"description": "matrix to be added", "type": "Keyword args"}, "alpha": {"description": "multiplier for `batch1 @ batch2` (:math:`\\alpha`)", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "addcdiv", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to be added", "type": "Args"}, "tensor1": {"description": "the numerator tensor", "type": "Args"}, "tensor2": {"description": "the denominator tensor", "type": "Args"}, "value": {"description": "multiplier for :math:`\\text{tensor1} / \\text{tensor2}`", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "addcmul", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to be added", "type": "Args"}, "tensor1": {"description": "the tensor to be multiplied", "type": "Args"}, "tensor2": {"description": "the tensor to be multiplied", "type": "Args"}, "value": {"description": "multiplier for :math:`tensor1 .* tensor2`", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "addmm", "ret_type": "Tensor", "signature": {"input": {"description": "matrix to be added", "type": "Args"}, "mat1": {"description": "the first matrix to be matrix multiplied", "type": "Args"}, "mat2": {"description": "the second matrix to be matrix multiplied", "type": "Args"}, "beta": {"description": "multiplier for :attr:`input` (:math:`\\beta`)", "type": "Keyword args"}, "alpha": {"description": "multiplier for :math:`mat1 @ mat2` (:math:`\\alpha`)", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "addmv", "ret_type": "Tensor", "signature": {"input": {"description": "vector to be added", "type": "Args"}, "mat": {"description": "matrix to be matrix multiplied", "type": "Args"}, "vec": {"description": "vector to be matrix multiplied", "type": "Args"}, "beta": {"description": "multiplier for :attr:`input` (:math:`\\beta`)", "type": "Keyword args"}, "alpha": {"description": "multiplier for :math:`mat @ vec` (:math:`\\alpha`)", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "addr", "ret_type": "Tensor", "signature": {"input": {"description": "matrix to be added", "type": "Args"}, "vec1": {"description": "the first vector of the outer product", "type": "Args"}, "vec2": {"description": "the second vector of the outer product", "type": "Args"}, "beta": {"description": "multiplier for :attr:`input` (:math:`\\beta`)", "type": "Keyword args"}, "alpha": {"description": "multiplier for :math:`\\text{vec1} \\otimes \\text{vec2}` (:math:`\\alpha`)", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "all", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "allclose", "ret_type": "bool", "signature": {"input": {"description": "first tensor to compare", "type": "Args"}, "other": {"description": "second tensor to compare", "type": "Args"}, "atol": {"description": "absolute tolerance.", "type": "Args"}, "rtol": {"description": "relative tolerance.", "type": "Args"}, "equal_nan": {"description": "if ``True``, then two ``NaN`` s will be considered equal.", "type": "Args"}}, "module": "torch"}, {"func_name": "amax", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "amin", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "aminmax", "ret_type": "(Tensor min, Tensor max)", "signature": {"input": {"description": "", "type": "Args"}, "keepdim": {"description": "", "type": "Args"}}, "module": "torch"}, {"func_name": "angle", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "..": {"description": "Starting in PyTorch 1.8, angle returns pi for negative real numbers,", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "any", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "arange", "ret_type": "Tensor", "signature": {"start": {"description": "the starting value for the set of points.", "type": "Args"}, "end": {"description": "the ending value for the set of points", "type": "Args"}, "step": {"description": "the gap between each pair of adjacent points.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "argmax", "ret_type": "LongTensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce. If ``None``, the argmax of the flattened input is returned.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not. Ignored if ``dim=None``.", "type": "Args"}}, "module": "torch"}, {"func_name": "argmin", "ret_type": "LongTensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce. If ``None``, the argmin of the flattened input is returned.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not..", "type": "Args"}}, "module": "torch"}, {"func_name": "argsort", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to sort along", "type": "Args"}, "descending": {"description": "controls the sorting order (ascending or descending)", "type": "Args"}, "stable": {"description": "controls the relative order of equivalent elements", "type": "Args"}}, "module": "torch"}, {"func_name": "as_strided", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "size": {"description": "the shape of the output tensor", "type": "Args"}, "stride": {"description": "the stride of the output tensor", "type": "Args"}, "storage_offset": {"description": "the offset in the underlying storage of the output tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "as_strided_scatter", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "size": {"description": "the shape of the output tensor", "type": "Args"}, "stride": {"description": "the stride of the output tensor", "type": "Args"}, "storage_offset": {"description": "the offset in the underlying storage of the output tensor", "type": "Args"}}, "module": "torch"}, {"func_name": "as_tensor", "ret_type": "Tensor", "signature": {"data": {"description": "Initial data for the tensor. Can be a list, tuple,", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Args"}, "device": {"description": "the device of the constructed tensor. If None and data is a tensor", "type": "Args"}}, "module": "torch"}, {"func_name": "asarray", "ret_type": "Tensor", "signature": {"obj": {"description": "a tensor, NumPy array, DLPack Capsule, object that implements Python's", "type": "Args"}, "dtype": {"description": "the datatype of the returned tensor.", "type": "Keyword args"}, "copy": {"description": "controls whether the returned tensor shares memory with :attr:`obj`.", "type": "Keyword args"}, "device": {"description": "the device of the returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "whether the returned tensor requires grad.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "asin", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "asinh", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "atan", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "atan2", "ret_type": "Tensor", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "atanh", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "autocast", "ret_type": null, "signature": {"enabled": {"description": "Whether autocasting should be enabled in the region.", "type": "Args"}, "dtype": {"description": "Whether to use torch.float16 or torch.bfloat16.", "type": "Args"}, "cache_enabled": {"description": "Whether the weight cache inside autocast should be enabled.", "type": "Args"}}, "module": "torch"}, {"func_name": "avg_pool1d", "ret_type": "Tensor", "signature": {"input": {"description": "input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iW)`", "type": "Args"}, "kernel_size": {"description": "the size of the window. Can be a single number or a", "type": "Args"}, "stride": {"description": "the stride of the window. Can be a single number or a tuple", "type": "Args"}, "padding": {"description": "implicit zero paddings on both sides of the input. Can be a", "type": "Args"}, "ceil_mode": {"description": "when True, will use `ceil` instead of `floor` to compute the", "type": "Args"}, "count_include_pad": {"description": "when True, will include the zero-padding in the", "type": "Args"}}, "module": "torch"}, {"func_name": "baddbmm", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to be added", "type": "Args"}, "batch1": {"description": "the first batch of matrices to be multiplied", "type": "Args"}, "batch2": {"description": "the second batch of matrices to be multiplied", "type": "Args"}, "beta": {"description": "multiplier for :attr:`input` (:math:`\\beta`)", "type": "Keyword args"}, "alpha": {"description": "multiplier for :math:`\\text{batch1} \\mathbin{@} \\text{batch2}` (:math:`\\alpha`)", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "bartlett_window", "ret_type": "Tensor", "signature": {"window_length": {"description": "the size of returned window", "type": "Arguments"}, "periodic": {"description": "If True, returns a window to be used as periodic", "type": "Arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned window tensor. Only", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "bernoulli", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor of probability values for the Bernoulli distribution", "type": "Args"}, "generator": {"description": "a pseudorandom number generator for sampling", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "bincount", "ret_type": "Tensor", "signature": {"input": {"description": "1-d int tensor", "type": "Arguments"}, "weights": {"description": "optional, weight for each value in the input tensor.", "type": "Arguments"}, "minlength": {"description": "optional, minimum number of bins. Should be non-negative.", "type": "Arguments"}}, "module": "torch"}, {"func_name": "bitwise_and", "ret_type": "Tensor", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "bitwise_left_shift", "ret_type": "Tensor", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "bitwise_not", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "bitwise_or", "ret_type": "Tensor", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "bitwise_right_shift", "ret_type": "Tensor", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "bitwise_xor", "ret_type": "Tensor", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "blackman_window", "ret_type": "Tensor", "signature": {"window_length": {"description": "the size of returned window", "type": "Arguments"}, "periodic": {"description": "If True, returns a window to be used as periodic", "type": "Arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned window tensor. Only", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "block_diag", "ret_type": null, "signature": {"*tensors": {"description": "One or more tensors with 0, 1, or 2 dimensions.", "type": "Args"}}, "module": "torch"}, {"func_name": "bmm", "ret_type": "Tensor", "signature": {"input": {"description": "the first batch of matrices to be multiplied", "type": "Args"}, "mat2": {"description": "the second batch of matrices to be multiplied", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "broadcast_shapes", "ret_type": "Size", "signature": {"\\*shapes": {"description": "Shapes of tensors.", "type": "Args"}}, "module": "torch"}, {"func_name": "broadcast_tensors", "ret_type": "List of Tensors", "signature": {"*tensors": {"description": "any number of tensors of the same type", "type": "Args"}}, "module": "torch"}, {"func_name": "broadcast_to", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "shape": {"description": "the new shape.", "type": "Args"}}, "module": "torch"}, {"func_name": "bucketize", "ret_type": "Tensor", "signature": {"input": {"description": "N-D tensor or a Scalar containing the search value(s).", "type": "Args"}, "boundaries": {"description": "1-D tensor, must contain a strictly increasing sequence, or the return value is undefined.", "type": "Args"}, "out_int32": {"description": "indicate the output data type. torch.int32 if True, torch.int64 otherwise.", "type": "Keyword args"}, "right": {"description": "if False, return the first suitable location that is found. If True, return the", "type": "Keyword args"}, "out": {"description": "the output tensor, must be the same size as :attr:`input` if provided.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "can_cast", "ret_type": "bool", "signature": {"from": {"description": "The original :class:`torch.dtype`.", "type": "Args"}, "to": {"description": "The target :class:`torch.dtype`.", "type": "Args"}}, "module": "torch"}, {"func_name": "cartesian_prod", "ret_type": null, "signature": {"*tensors": {"description": "any number of 1 dimensional tensors.", "type": "Args"}}, "module": "torch"}, {"func_name": "cat", "ret_type": "Tensor", "signature": {"tensors": {"description": "any python sequence of tensors of the same type.", "type": "Args"}, "dim": {"description": "the dimension over which the tensors are concatenated", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "cdist", "ret_type": null, "signature": {"x1": {"description": "input tensor of shape :math:`B \\times P \\times M`.", "type": "Args"}, "x2": {"description": "input tensor of shape :math:`B \\times R \\times M`.", "type": "Args"}, "p": {"description": "p value for the p-norm distance to calculate between each vector pair", "type": "Args"}, "'use_mm_for_euclid_dist_if_necessary'": {"description": "will use matrix multiplication approach to calculate", "type": "Args"}, "'use_mm_for_euclid_dist'": {"description": "will always use matrix multiplication approach to calculate", "type": "Args"}, "'donot_use_mm_for_euclid_dist'": {"description": "will never use matrix multiplication approach to calculate", "type": "Args"}}, "module": "torch"}, {"func_name": "ceil", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "chain_matmul", "ret_type": null, "signature": {"matrices": {"description": "a sequence of 2 or more 2-D tensors whose product is to be determined.", "type": "Args"}, "out": {"description": "the output tensor. Ignored if :attr:`out` = ``None``.", "type": "Args"}}, "module": "torch"}, {"func_name": "channel_shuffle", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor", "type": "Args"}, "groups": {"description": "number of groups to divide channels in and rearrange.", "type": "Args"}}, "module": "torch"}, {"func_name": "cholesky", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor :math:`A` of size :math:`(*, n, n)` where `*` is zero or more", "type": "Args"}, "upper": {"description": "flag that indicates whether to return a", "type": "Args"}, "out": {"description": "the output matrix", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "cholesky_inverse", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor :math:`A` of size :math:`(*, n, n)`,", "type": "Args"}, "upper": {"description": "flag that indicates whether to return a", "type": "Args"}, "out": {"description": "the output tensor for `inv`", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "cholesky_solve", "ret_type": "Tensor", "signature": {"input": {"description": "input matrix :math:`b` of size :math:`(*, m, k)`,", "type": "Args"}, "input2": {"description": "input matrix :math:`u` of size :math:`(*, m, m)`,", "type": "Args"}, "upper": {"description": "whether to consider the Cholesky factor as a", "type": "Args"}, "out": {"description": "the output tensor for `c`", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "chunk", "ret_type": "List of Tensors", "signature": {"input": {"description": "the tensor to split", "type": "Arguments"}, "chunks": {"description": "number of chunks to return", "type": "Arguments"}, "dim": {"description": "dimension along which to split the tensor", "type": "Arguments"}}, "module": "torch"}, {"func_name": "clamp", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "min": {"description": "lower-bound of the range to be clamped to", "type": "Args"}, "max": {"description": "upper-bound of the range to be clamped to", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "clone", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "column_stack", "ret_type": "Tensor", "signature": {"tensors": {"description": "sequence of tensors to concatenate", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "combinations", "ret_type": "seq", "signature": {"input": {"description": "1D vector.", "type": "Arguments"}, "r": {"description": "number of elements to combine", "type": "Arguments"}, "with_replacement": {"description": "whether to allow duplication in combination", "type": "Arguments"}}, "module": "torch"}, {"func_name": "compile", "ret_type": null, "signature": {"model": {"description": "Module/function to optimize", "type": "Args"}, "fullgraph": {"description": "Whether it is ok to break model into several subgraphs", "type": "Args"}, "dynamic": {"description": "Use dynamic shape tracing.  When this is True, we will up-front attempt", "type": "Args"}, "backend": {"description": "backend to be used", "type": "Args"}, "-": {"description": "https://pytorch.org/docs/main/compile/custom-backends.html", "type": "Args"}, "mode": {"description": "Can be either \"default\", \"reduce-overhead\", \"max-autotune\" or \"max-autotune-no-cudagraphs\"", "type": "Args"}, "options": {"description": "A dictionary of options to pass to the backend. Some notable ones to try out are", "type": "Args"}, "disable": {"description": "Turn torch.compile() into a no-op for testing", "type": "Args"}}, "module": "torch"}, {"func_name": "complex", "ret_type": "Tensor", "signature": {"real": {"description": "The real part of the complex tensor. Must be half, float or double.", "type": "Args"}, "imag": {"description": "The imaginary part of the complex tensor. Must be same dtype", "type": "Args"}, "out": {"description": "If the inputs are ``torch.float32``, must be", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "conj", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "conj_physical", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "conv1d", "ret_type": "Tensor", "signature": {"input": {"description": "input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iW)`", "type": "Args"}, "weight": {"description": "filters of shape :math:`(\\text{out\\_channels} , \\frac{\\text{in\\_channels}}{\\text{groups}} , kW)`", "type": "Args"}, "bias": {"description": "optional bias of shape :math:`(\\text{out\\_channels})`.", "type": "Args"}, "stride": {"description": "the stride of the convolving kernel. Can be a single number or", "type": "Args"}, "padding": {"description": "implicit paddings on both sides of the input. Can be a string {'valid', 'same'},", "type": "Args"}, "dilation": {"description": "the spacing between kernel elements. Can be a single number or", "type": "Args"}, "groups": {"description": "split input into groups, :math:`\\text{in\\_channels}` should be divisible by", "type": "Args"}}, "module": "torch"}, {"func_name": "conv2d", "ret_type": "Tensor", "signature": {"input": {"description": "input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iH , iW)`", "type": "Args"}, "weight": {"description": "filters of shape :math:`(\\text{out\\_channels} , \\frac{\\text{in\\_channels}}{\\text{groups}} , kH , kW)`", "type": "Args"}, "bias": {"description": "optional bias tensor of shape :math:`(\\text{out\\_channels})`.", "type": "Args"}, "stride": {"description": "the stride of the convolving kernel. Can be a single number or a", "type": "Args"}, "padding": {"description": "implicit paddings on both sides of the input. Can be a string {'valid', 'same'},", "type": "Args"}, "dilation": {"description": "the spacing between kernel elements. Can be a single number or", "type": "Args"}, "groups": {"description": "split input into groups, both :math:`\\text{in\\_channels}` and :math:`\\text{out\\_channels}`", "type": "Args"}}, "module": "torch"}, {"func_name": "conv3d", "ret_type": "Tensor", "signature": {"input": {"description": "input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iT , iH , iW)`", "type": "Args"}, "weight": {"description": "filters of shape :math:`(\\text{out\\_channels} , \\frac{\\text{in\\_channels}}{\\text{groups}} , kT , kH , kW)`", "type": "Args"}, "bias": {"description": "optional bias tensor of shape :math:`(\\text{out\\_channels})`.", "type": "Args"}, "stride": {"description": "the stride of the convolving kernel. Can be a single number or a", "type": "Args"}, "padding": {"description": "implicit paddings on both sides of the input. Can be a string {'valid', 'same'},", "type": "Args"}, "dilation": {"description": "the spacing between kernel elements. Can be a single number or", "type": "Args"}, "groups": {"description": "split input into groups, :math:`\\text{in\\_channels}` should be divisible by", "type": "Args"}}, "module": "torch"}, {"func_name": "conv_tbc", "ret_type": null, "signature": {"input": {"description": "input tensor of shape :math:`(\\text{sequence length} \\times batch \\times \\text{in\\_channels})`", "type": "Args"}, "weight": {"description": "filter of shape (:math:`\\text{kernel width} \\times \\text{in\\_channels} \\times \\text{out\\_channels}`)", "type": "Args"}, "bias": {"description": "bias of shape (:math:`\\text{out\\_channels}`)", "type": "Args"}}, "module": "torch"}, {"func_name": "conv_transpose1d", "ret_type": "Tensor", "signature": {"input": {"description": "input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iW)`", "type": "Args"}, "weight": {"description": "filters of shape :math:`(\\text{in\\_channels} , \\frac{\\text{out\\_channels}}{\\text{groups}} , kW)`", "type": "Args"}, "bias": {"description": "optional bias of shape :math:`(\\text{out\\_channels})`.", "type": "Args"}, "stride": {"description": "the stride of the convolving kernel. Can be a single number or a", "type": "Args"}, "output_padding": {"description": "additional size added to one side of each dimension in the", "type": "Args"}, "groups": {"description": "split input into groups, :math:`\\text{in\\_channels}` should be divisible by the", "type": "Args"}, "dilation": {"description": "the spacing between kernel elements. Can be a single number or", "type": "Args"}}, "module": "torch"}, {"func_name": "conv_transpose2d", "ret_type": "Tensor", "signature": {"input": {"description": "input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iH , iW)`", "type": "Args"}, "weight": {"description": "filters of shape :math:`(\\text{in\\_channels} , \\frac{\\text{out\\_channels}}{\\text{groups}} , kH , kW)`", "type": "Args"}, "bias": {"description": "optional bias of shape :math:`(\\text{out\\_channels})`.", "type": "Args"}, "stride": {"description": "the stride of the convolving kernel. Can be a single number or a", "type": "Args"}, "output_padding": {"description": "additional size added to one side of each dimension in the", "type": "Args"}, "groups": {"description": "split input into groups, :math:`\\text{in\\_channels}` should be divisible by the", "type": "Args"}, "dilation": {"description": "the spacing between kernel elements. Can be a single number or", "type": "Args"}}, "module": "torch"}, {"func_name": "conv_transpose3d", "ret_type": "Tensor", "signature": {"input": {"description": "input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iT , iH , iW)`", "type": "Args"}, "weight": {"description": "filters of shape :math:`(\\text{in\\_channels} , \\frac{\\text{out\\_channels}}{\\text{groups}} , kT , kH , kW)`", "type": "Args"}, "bias": {"description": "optional bias of shape :math:`(\\text{out\\_channels})`.", "type": "Args"}, "stride": {"description": "the stride of the convolving kernel. Can be a single number or a", "type": "Args"}, "output_padding": {"description": "additional size added to one side of each dimension in the", "type": "Args"}, "groups": {"description": "split input into groups, :math:`\\text{in\\_channels}` should be divisible by the", "type": "Args"}, "dilation": {"description": "the spacing between kernel elements. Can be a single number or", "type": "Args"}}, "module": "torch"}, {"func_name": "copysign", "ret_type": "Tensor", "signature": {"input": {"description": "magnitudes.", "type": "Args"}, "other": {"description": "contains value(s) whose signbit(s) are", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "corrcoef", "ret_type": "Tensor", "signature": {"input": {"description": "A 2D matrix containing multiple variables and observations, or a", "type": "Args"}}, "module": "torch"}, {"func_name": "cos", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "cosh", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "cosine_similarity", "ret_type": "Tensor", "signature": {"x1": {"description": "First input.", "type": "Args"}, "x2": {"description": "Second input.", "type": "Args"}, "dim": {"description": "Dimension along which cosine similarity is computed.", "type": "Args"}, "eps": {"description": "Small value to avoid division by zero.", "type": "Args"}}, "module": "torch"}, {"func_name": "count_nonzero", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "Dim or tuple of dims along which to count non-zeros.", "type": "Args"}}, "module": "torch"}, {"func_name": "cov", "ret_type": "Tensor", "signature": {"input": {"description": "A 2D matrix containing multiple variables and observations, or a", "type": "Args"}, "correction": {"description": "difference between the sample size and sample degrees of freedom.", "type": "Args"}, "fweights": {"description": "A Scalar or 1D tensor of observation vector frequencies representing the number of", "type": "Args"}, "aweights": {"description": "A Scalar or 1D array of observation vector weights.", "type": "Args"}}, "module": "torch"}, {"func_name": "cross", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "dim": {"description": "the dimension to take the cross-product in.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "cummax", "ret_type": null, "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to do the operation over", "type": "Args"}, "out": {"description": "the result tuple of two output tensors (values, indices)", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "cummin", "ret_type": null, "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to do the operation over", "type": "Args"}, "out": {"description": "the result tuple of two output tensors (values, indices)", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "cumprod", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to do the operation over", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "cumsum", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to do the operation over", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "cumulative_trapezoid", "ret_type": "Tensor", "signature": {"y": {"description": "Values to use when computing the trapezoidal rule.", "type": "Arguments"}, "x": {"description": "If specified, defines spacing between values as specified above.", "type": "Arguments"}, "dx": {"description": "constant spacing between values. If neither :attr:`x` or :attr:`dx`", "type": "Keyword arguments"}, "dim": {"description": "The dimension along which to compute the trapezoidal rule.", "type": "Keyword arguments"}, ">>>": {"description": "1) * (1 + 5)) / 2", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "deg2rad", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "dequantize", "ret_type": "Tensor", "signature": {"tensor": {"description": "A quantized Tensor", "type": "Args"}, "..": {"description": "dequantize(tensors) -> sequence of Tensors", "type": "Args"}}, "module": "torch"}, {"func_name": "diag", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "diagonal": {"description": "the diagonal to consider", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "diag_embed", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor. Must be at least 1-dimensional.", "type": "Args"}, "offset": {"description": "which diagonal to consider.", "type": "Args"}, "dim1": {"description": "first dimension with respect to which to", "type": "Args"}, "dim2": {"description": "second dimension with respect to which to", "type": "Args"}}, "module": "torch"}, {"func_name": "diagflat", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "offset": {"description": "the diagonal to consider.", "type": "Args"}}, "module": "torch"}, {"func_name": "diagonal", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor. Must be at least 2-dimensional.", "type": "Args"}, "offset": {"description": "which diagonal to consider.", "type": "Args"}, "dim1": {"description": "first dimension with respect to which to", "type": "Args"}, "dim2": {"description": "second dimension with respect to which to", "type": "Args"}, "..": {"description": "To take a batch diagonal, pass in dim1=-2, dim2=-1.", "type": "Args"}}, "module": "torch"}, {"func_name": "diagonal_scatter", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor. Must be at least 2-dimensional.", "type": "Args"}, "src": {"description": "the tensor to embed into :attr:`input`.", "type": "Args"}, "offset": {"description": "which diagonal to consider.", "type": "Args"}, "dim1": {"description": "first dimension with respect to which to", "type": "Args"}, "dim2": {"description": "second dimension with respect to which to", "type": "Args"}}, "module": "torch"}, {"func_name": "diff", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to compute the differences on", "type": "Args"}, "n": {"description": "the number of times to recursively compute the difference", "type": "Args"}, "dim": {"description": "the dimension to compute the difference along.", "type": "Args"}, "prepend,": {"description": "values to prepend or append to", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "dist", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the Right-hand-side input tensor", "type": "Args"}, "p": {"description": "the norm to be computed", "type": "Args"}}, "module": "torch"}, {"func_name": "div", "ret_type": "Tensor", "signature": {"input": {"description": "the dividend", "type": "Args"}, "other": {"description": "the divisor", "type": "Args"}, "rounding_mode": {"description": "Type of rounding applied to the result:", "type": "Keyword args"}, "*": {"description": "rounds the results of the division down.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "dot", "ret_type": "Tensor", "signature": {"input": {"description": "first tensor in the dot product, must be 1D.", "type": "Args"}, "other": {"description": "second tensor in the dot product, must be 1D.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "dsplit", "ret_type": "List of Tensors", "signature": {"input": {"description": "tensor to split.", "type": "Args"}, "indices_or_sections": {"description": "See argument in :func:`torch.tensor_split`.", "type": "Args"}}, "module": "torch"}, {"func_name": "dstack", "ret_type": "Tensor", "signature": {"tensors": {"description": "sequence of tensors to concatenate", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "einsum", "ret_type": "Tensor", "signature": {"equation": {"description": "The subscripts for the Einstein summation.", "type": "Args"}, "operands": {"description": "The tensors to compute the Einstein summation of.", "type": "Args"}, ">>>": {"description": "+IGNORE_WANT(\"non-deterministic\")", "type": "Args"}}, "module": "torch"}, {"func_name": "empty", "ret_type": "Tensor", "signature": {"size": {"description": "a sequence of integers defining the shape of the output tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "empty_like", "ret_type": "Tensor", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned Tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "empty_permuted", "ret_type": "Tensor", "signature": {"size": {"description": "the shape of the output tensor", "type": "Args"}, "physical_layout": {"description": "the ordering of dimensions physically in memory", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "empty_strided", "ret_type": "Tensor", "signature": {"size": {"description": "the shape of the output tensor", "type": "Args"}, "stride": {"description": "the strides of the output tensor", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "eq", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "exp", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "eye", "ret_type": "Tensor", "signature": {"n": {"description": "the number of rows", "type": "Args"}, "m": {"description": "the number of columns with default being :attr:`n`", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword arguments"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword arguments"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword arguments"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "fake_quantize_per_channel_affine", "ret_type": "Tensor", "signature": {"input": {"description": "the input value(s), in ``torch.float32``", "type": "Args"}, "scale": {"description": "quantization scale, per channel in ``torch.float32``", "type": "Args"}, "zero_point": {"description": "quantization zero_point, per channel in ``torch.int32`` or ``torch.half`` or ``torch.float32``", "type": "Args"}, "axis": {"description": "channel axis", "type": "Args"}, "quant_min": {"description": "lower bound of the quantized domain", "type": "Args"}, "quant_max": {"description": "upper bound of the quantized domain", "type": "Args"}}, "module": "torch"}, {"func_name": "fake_quantize_per_tensor_affine", "ret_type": "Tensor", "signature": {"input": {"description": "the input value(s), ``torch.float32`` tensor", "type": "Args"}, "scale": {"description": "quantization scale", "type": "Args"}, "zero_point": {"description": "quantization zero_point", "type": "Args"}, "quant_min": {"description": "lower bound of the quantized domain", "type": "Args"}, "quant_max": {"description": "upper bound of the quantized domain", "type": "Args"}}, "module": "torch"}, {"func_name": "flatten", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "start_dim": {"description": "the first dim to flatten", "type": "Args"}, "end_dim": {"description": "the last dim to flatten", "type": "Args"}}, "module": "torch"}, {"func_name": "flip", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dims": {"description": "axis to flip on", "type": "Args"}}, "module": "torch"}, {"func_name": "fliplr", "ret_type": "Tensor", "signature": {"input": {"description": "Must be at least 2-dimensional.", "type": "Args"}}, "module": "torch"}, {"func_name": "flipud", "ret_type": "Tensor", "signature": {"input": {"description": "Must be at least 1-dimensional.", "type": "Args"}}, "module": "torch"}, {"func_name": "float_power", "ret_type": "Tensor", "signature": {"input": {"description": "the base value(s)", "type": "Args"}, "exponent": {"description": "the exponent value(s)", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "floor", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "floor_divide", "ret_type": "Tensor", "signature": {"input": {"description": "the dividend", "type": "Args"}, "other": {"description": "the divisor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "fmax", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "fmin", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "fmod", "ret_type": "Tensor", "signature": {"input": {"description": "the dividend", "type": "Args"}, "other": {"description": "the divisor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "frexp", "ret_type": "(Tensor mantissa, Tensor exponent)", "signature": {"input": {"description": "the input tensor", "type": "Args"}, "out": {"description": "the output tensors", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "from_dlpack", "ret_type": "Tensor", "signature": {"ext_tensor": {"description": "", "type": "Args"}}, "module": "torch"}, {"func_name": "frombuffer", "ret_type": "Tensor", "signature": {"buffer": {"description": "a Python object that exposes the buffer interface.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "count": {"description": "the number of desired elements to be read.", "type": "Keyword args"}, "offset": {"description": "the number of bytes to skip at the start of", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "full", "ret_type": "Tensor", "signature": {"size": {"description": "a list, tuple, or :class:`torch.Size` of integers defining the", "type": "Args"}, "fill_value": {"description": "the value to fill the output tensor with.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "full_like", "ret_type": "Tensor", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "fill_value": {"description": "the number to fill the output tensor with.", "type": "Args"}, "dtype": {"description": "the desired data type of returned Tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "gather", "ret_type": "Tensor", "signature": {"input": {"description": "the source tensor", "type": "Args"}, "dim": {"description": "the axis along which to index", "type": "Args"}, "index": {"description": "the indices of elements to gather", "type": "Args"}, "sparse_grad": {"description": "If ``True``, gradient w.r.t. :attr:`input` will be a sparse tensor.", "type": "Keyword arguments"}, "out": {"description": "the destination tensor", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "gcd", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "ge", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "geqrf", "ret_type": "(Tensor, Tensor)", "signature": {"input": {"description": "the input matrix", "type": "Args"}, "out": {"description": "the output tuple of (Tensor, Tensor). Ignored if `None`.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "gradient", "ret_type": "List of Tensors", "signature": {"input": {"description": "the tensor that represents the values of the function", "type": "Args"}, "spacing": {"description": ":attr:`spacing` can be used to modify", "type": "Keyword args"}, "dim": {"description": "the dimension or dimensions to approximate the gradient over.  By default", "type": "Keyword args"}, "edge_order": {"description": "1 or 2, for `first-order", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "gt", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "hamming_window", "ret_type": "Tensor", "signature": {"window_length": {"description": "the size of returned window", "type": "Arguments"}, "periodic": {"description": "If True, returns a window to be used as periodic", "type": "Arguments"}, "alpha": {"description": "The coefficient :math:`\\alpha` in the equation above", "type": "Arguments"}, "beta": {"description": "The coefficient :math:`\\beta` in the equation above", "type": "Arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned window tensor. Only", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "hann_window", "ret_type": "Tensor", "signature": {"window_length": {"description": "the size of returned window", "type": "Arguments"}, "periodic": {"description": "If True, returns a window to be used as periodic", "type": "Arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned window tensor. Only", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "heaviside", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "values": {"description": "The values to use where :attr:`input` is zero.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "histc", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "bins": {"description": "number of histogram bins", "type": "Args"}, "min": {"description": "lower end of the range (inclusive)", "type": "Args"}, "max": {"description": "upper end of the range (inclusive)", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "histogram", "ret_type": "(Tensor, Tensor)", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "bins": {"description": "int or 1D Tensor. If int, defines the number of equal-width bins. If tensor,", "type": "Args"}, "range": {"description": "Defines the range of the bins.", "type": "Keyword args"}, "weight": {"description": "If provided, weight should have the same shape as input. Each value in", "type": "Keyword args"}, "density": {"description": "If False, the result will contain the count (or total weight) in each bin.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "histogramdd", "ret_type": "(Tensor, Tensor[])", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "bins": {"description": "Tensor[], int[], or int.", "type": "Args"}, "range": {"description": "Defines the leftmost and rightmost bin edges", "type": "Keyword args"}, "weight": {"description": "By default, each value in the input has weight 1. If a weight", "type": "Keyword args"}, "density": {"description": "If False (default), the result will contain the count (or total weight)", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "hsplit", "ret_type": "List of Tensors", "signature": {"input": {"description": "tensor to split.", "type": "Args"}, "indices_or_sections": {"description": "See argument in :func:`torch.tensor_split`.", "type": "Args"}}, "module": "torch"}, {"func_name": "hspmm", "ret_type": "Tensor", "signature": {"mat1": {"description": "the first sparse matrix to be matrix multiplied", "type": "Args"}, "mat2": {"description": "the second strided matrix to be matrix multiplied", "type": "Args"}}, "module": "torch"}, {"func_name": "hstack", "ret_type": "Tensor", "signature": {"tensors": {"description": "sequence of tensors to concatenate", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "hypot", "ret_type": "Tensor", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "imag", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "index_select", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension in which we index", "type": "Args"}, "index": {"description": "the 1-D tensor containing the indices to index", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "inference_mode", "ret_type": null, "signature": {"mode": {"description": "Either a boolean flag whether to enable or", "type": "Args"}}, "module": "torch"}, {"func_name": "inner", "ret_type": "Tensor", "signature": {"input": {"description": "First input tensor", "type": "Args"}, "other": {"description": "Second input tensor", "type": "Args"}, "out": {"description": "Optional output tensor to write result into. The output", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "is_nonzero", "ret_type": "(bool)", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "Traceback": {"description": "", "type": "Args"}, "RuntimeError": {"description": "bool value of Tensor with more than one value is ambiguous", "type": "Args"}}, "module": "torch"}, {"func_name": "is_storage", "ret_type": null, "signature": {"obj": {"description": "Object to test", "type": "Args"}}, "module": "torch"}, {"func_name": "is_tensor", "ret_type": null, "signature": {"obj": {"description": "Object to test", "type": "Args"}}, "module": "torch"}, {"func_name": "isclose", "ret_type": "Tensor", "signature": {"input": {"description": "first tensor to compare", "type": "Args"}, "other": {"description": "second tensor to compare", "type": "Args"}, "atol": {"description": "absolute tolerance.", "type": "Args"}, "rtol": {"description": "relative tolerance.", "type": "Args"}, "equal_nan": {"description": "if ``True``, then two ``NaN`` s will be considered equal.", "type": "Args"}}, "module": "torch"}, {"func_name": "isfinite", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "isin", "ret_type": "Tensor", "signature": {"elements": {"description": "Input elements", "type": "Args"}, "test_elements": {"description": "Values against which to test for each input element", "type": "Args"}, "assume_unique": {"description": "If True, assumes both :attr:`elements` and", "type": "Args"}, "invert": {"description": "If True, inverts the boolean return tensor, resulting in True", "type": "Args"}}, "module": "torch"}, {"func_name": "isinf", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "isnan", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Arguments"}}, "module": "torch"}, {"func_name": "isneginf", "ret_type": null, "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "isposinf", "ret_type": null, "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "isreal", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Arguments"}}, "module": "torch"}, {"func_name": "istft", "ret_type": "Tensor:", "signature": {"input": {"description": "The input tensor. Expected to be in the format of :func:`~torch.stft`,", "type": "Args"}, "or": {"description": "n_fft) // hop_length` otherwise.", "type": "Args"}, "..": {"description": "2.0", "type": "Args"}, "n_fft": {"description": "Size of Fourier transform", "type": "Args"}, "hop_length": {"description": "The distance between neighboring sliding window frames.", "type": "Args"}, "win_length": {"description": "The size of window frame and STFT filter. (", "type": "Args"}, "window": {"description": "The optional window function.", "type": "Args"}, "center": {"description": "Whether :attr:`input` was padded on both sides so that the :math:`t`-th frame is", "type": "Args"}, "normalized": {"description": "Whether the STFT was normalized. (", "type": "Args"}, "onesided": {"description": "Whether the STFT was onesided.", "type": "Args"}, "length": {"description": "The amount to trim the signal by (i.e. the", "type": "Args"}, "original": {"description": "1) * hop_length` for", "type": "Args"}, "centered": {"description": "1) * hop_length` otherwise, where `T`", "type": "Args"}}, "module": "torch"}, {"func_name": "kaiser_window", "ret_type": "Tensor", "signature": {"window_length": {"description": "length of the window.", "type": "Args"}, "periodic": {"description": "If True, returns a periodic window suitable for use in spectral analysis.", "type": "Args"}, "beta": {"description": "shape parameter for the window.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned window tensor. Only", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "kron", "ret_type": "Tensor", "signature": {"out": {"description": "The output tensor. Ignored if ``None``.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "kthvalue", "ret_type": "(Tensor, LongTensor)", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "k": {"description": "k for the k-th smallest element", "type": "Args"}, "dim": {"description": "the dimension to find the kth value along", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tuple of (Tensor, LongTensor)", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "lcm", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "ldexp", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "a tensor of exponents, typically integers.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "le", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "lerp", "ret_type": null, "signature": {"input": {"description": "the tensor with the starting points", "type": "Args"}, "end": {"description": "the tensor with the ending points", "type": "Args"}, "weight": {"description": "the weight for the interpolation formula", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "lgamma", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "linspace", "ret_type": "Tensor", "signature": {"start": {"description": "the starting value for the set of points", "type": "Args"}, "end": {"description": "the ending value for the set of points", "type": "Args"}, "steps": {"description": "size of the constructed tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}, "dtype": {"description": "the data type to perform the computation in.", "type": "Keyword arguments"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword arguments"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword arguments"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "load", "ret_type": null, "signature": {"f": {"description": "a file-like object (has to implement :meth:`read`, :meth:`readline`, :meth:`tell`, and :meth:`seek`),", "type": "Args"}, "map_location": {"description": "a function, :class:`torch.device`, string or a dict specifying how to remap storage", "type": "Args"}, "pickle_module": {"description": "module used for unpickling metadata and objects (has to", "type": "Args"}, "weights_only": {"description": "Indicates whether unpickler should be restricted to", "type": "Args"}, "mmap": {"description": "Indicates whether the file should be mmaped rather than loading all the storages into memory.", "type": "Args"}, "pickle_load_args": {"description": "(Python 3 only) optional keyword arguments passed over to", "type": "Args"}, "case": {"description": "'ascii' codec can't decode byte 0x...``", "type": "Args"}, ">>>": {"description": "'cuda:0'})", "type": "Args"}}, "module": "torch"}, {"func_name": "lobpcg", "ret_type": null, "signature": {"A": {"description": "the input tensor of size :math:`(*, m, m)`", "type": "Args"}, "B": {"description": "the input tensor of size :math:`(*, m,", "type": "Args"}, "X": {"description": "the input tensor of size :math:`(*, m, n)`", "type": "Args"}, "iK": {"description": "the input tensor of size :math:`(*, m,", "type": "Args"}, "k": {"description": "the number of requested", "type": "Args"}, "n": {"description": "if :math:`X` is not specified then `n`", "type": "Args"}, "tol": {"description": "residual tolerance for stopping", "type": "Args"}, "largest": {"description": "when True, solve the eigenproblem for", "type": "Args"}, "method": {"description": "select LOBPCG method. See the", "type": "Args"}, "niter": {"description": "maximum number of iterations. When", "type": "Args"}, "tracker": {"description": "a function for tracing the", "type": "Args"}, "`iparams`,": {"description": "dictionaries of", "type": "Args"}, "`ivars`,": {"description": "dictionaries", "type": "Args"}, "`A`,": {"description": "input Tensor arguments.", "type": "Args"}, "`E`,": {"description": "iteration Tensor variables.", "type": "Args"}, "`ivars[\"istep\"]`": {"description": "the current iteration step", "type": "Args"}, "`X`": {"description": "the current approximation of eigenvectors", "type": "Args"}, "`E`": {"description": "the current approximation of eigenvalues", "type": "Args"}, "`R`": {"description": "the current residual", "type": "Args"}, "`ivars[\"converged_count\"]`": {"description": "the current number of converged eigenpairs", "type": "Args"}, "`tvars[\"rerr\"]`": {"description": "the current state of convergence criteria", "type": "Args"}, "ortho_iparams,": {"description": "", "type": "Args"}}, "module": "torch"}, {"func_name": "log", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "log10", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "log1p", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "log2", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "logaddexp", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "logaddexp2", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}}, "module": "torch"}, {"func_name": "logcumsumexp", "ret_type": null, "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to do the operation over", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "logdet", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor of size ``(*, n, n)`` where ``*`` is zero or more", "type": "Arguments"}}, "module": "torch"}, {"func_name": "logical_and", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the tensor to compute AND with", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "logical_not", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "logical_or", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the tensor to compute OR with", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "logical_xor", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the tensor to compute XOR with", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "logspace", "ret_type": "Tensor", "signature": {"start": {"description": "the starting value for the set of points", "type": "Args"}, "end": {"description": "the ending value for the set of points", "type": "Args"}, "steps": {"description": "size of the constructed tensor", "type": "Args"}, "base": {"description": "base of the logarithm function.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}, "dtype": {"description": "the data type to perform the computation in.", "type": "Keyword arguments"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword arguments"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword arguments"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "logsumexp", "ret_type": null, "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "lt", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "lu", "ret_type": null, "signature": {"A": {"description": "the tensor to factor of size :math:`(*, m, n)`", "type": "Args"}, "pivot": {"description": "controls whether pivoting is done.", "type": "Args"}, "get_infos": {"description": "if set to ``True``, returns an info IntTensor.", "type": "Args"}, "out": {"description": "optional output tuple. If :attr:`get_infos` is ``True``,", "type": "Args"}}, "module": "torch"}, {"func_name": "lu_solve", "ret_type": "Tensor", "signature": {"b": {"description": "the RHS tensor of size :math:`(*, m, k)`, where :math:`*`", "type": "Arguments"}, "LU_data": {"description": "the pivoted LU factorization of A from :meth:`~linalg.lu_factor` of size :math:`(*, m, m)`,", "type": "Arguments"}, "LU_pivots": {"description": "the pivots of the LU factorization from :meth:`~linalg.lu_factor` of size :math:`(*, m)`,", "type": "Arguments"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "lu_unpack", "ret_type": "(Tensor, Tensor, Tensor)", "signature": {"LU_data": {"description": "the packed LU factorization data", "type": "Args"}, "LU_pivots": {"description": "the packed LU factorization pivots", "type": "Args"}, "unpack_data": {"description": "flag indicating if the data should be unpacked.", "type": "Args"}, "unpack_pivots": {"description": "flag indicating if the pivots should be unpacked into a permutation matrix ``P``.", "type": "Args"}, "out": {"description": "output tuple of three tensors. Ignored if `None`.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "manual_seed", "ret_type": null, "signature": {"seed": {"description": "The desired seed. Value must be within the inclusive range", "type": "Args"}}, "module": "torch"}, {"func_name": "masked_select", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "mask": {"description": "the tensor containing the binary mask to index with", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "matmul", "ret_type": "Tensor", "signature": {"input": {"description": "the first tensor to be multiplied", "type": "Arguments"}, "other": {"description": "the second tensor to be multiplied", "type": "Arguments"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "max", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the result tuple of two output tensors (max, max_indices)", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "maximum", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "mean", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "median", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "The first tensor will be populated with the median values and the second", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "meshgrid", "ret_type": null, "signature": {"tensors": {"description": "list of scalars or 1 dimensional tensors. Scalars will be", "type": "Args"}}, "module": "torch"}, {"func_name": "min", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the tuple of two output tensors (min, min_indices)", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "minimum", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "mm", "ret_type": "Tensor", "signature": {"input": {"description": "the first matrix to be matrix multiplied", "type": "Args"}, "mat2": {"description": "the second matrix to be matrix multiplied", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "mode", "ret_type": "(Tensor, LongTensor)", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the result tuple of two output tensors (values, indices)", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "movedim", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "source": {"description": "Original positions of the dims to move. These must be unique.", "type": "Args"}, "destination": {"description": "Destination positions for each of the original dims. These must also be unique.", "type": "Args"}}, "module": "torch"}, {"func_name": "msort", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "mul", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the tensor or number to multiply input by.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "multinomial", "ret_type": "LongTensor", "signature": {"input": {"description": "the input tensor containing probabilities", "type": "Args"}, "num_samples": {"description": "number of samples to draw", "type": "Args"}, "replacement": {"description": "whether to draw with replacement or not", "type": "Args"}, "generator": {"description": "a pseudorandom number generator for sampling", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "mv", "ret_type": "Tensor", "signature": {"input": {"description": "matrix to be multiplied", "type": "Args"}, "vec": {"description": "vector to be multiplied", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "nan_to_num", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "nan": {"description": "the value to replace :literal:`NaN`\\s with. Default is zero.", "type": "Args"}, "posinf": {"description": "if a Number, the value to replace positive infinity values with.", "type": "Args"}, "neginf": {"description": "if a Number, the value to replace negative infinity values with.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "nanmean", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "nanmedian", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "The first tensor will be populated with the median values and the second", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "nanquantile", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "q": {"description": "a scalar or 1D tensor of quantile values in the range [0, 1]", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "interpolation": {"description": "interpolation method to use when the desired quantile lies between two data points.", "type": "Keyword arguments"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "nansum", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}}, "module": "torch"}, {"func_name": "narrow", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to narrow", "type": "Args"}, "dim": {"description": "the dimension along which to narrow", "type": "Args"}, "start": {"description": "index of the element to start the narrowed dimension", "type": "Args"}, "length": {"description": "length of the narrowed dimension, must be weakly positive", "type": "Args"}}, "module": "torch"}, {"func_name": "narrow_copy", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to narrow", "type": "Args"}, "dim": {"description": "the dimension along which to narrow", "type": "Args"}, "start": {"description": "index of the element to start the narrowed dimension from. Can", "type": "Args"}, "length": {"description": "length of the narrowed dimension, must be weakly positive", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "native_channel_shuffle", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor", "type": "Args"}, "groups": {"description": "number of groups to divide channels in and rearrange.", "type": "Args"}}, "module": "torch"}, {"func_name": "ne", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "neg", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "nextafter", "ret_type": "Tensor", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "nonzero", "ret_type": "LongTensor or tuple of LongTensors", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor containing indices", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "norm", "ret_type": null, "signature": {"input": {"description": "The input tensor. Its data type must be either a floating", "type": "Args"}, "p": {"description": "the order of norm.", "type": "Args"}, "dim": {"description": "", "type": "Args"}, "keepdim": {"description": "whether the output tensors have :attr:`dim`", "type": "Args"}, "out": {"description": "the output tensor. Ignored if", "type": "Args"}, "dtype": {"description": "the desired data type of", "type": "Args"}}, "module": "torch"}, {"func_name": "normal", "ret_type": "Tensor", "signature": {"mean": {"description": "the mean for all distributions", "type": "Args"}, "std": {"description": "the standard deviation for all distributions", "type": "Args"}, "generator": {"description": "a pseudorandom number generator for sampling", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "size": {"description": "a sequence of integers defining the shape of the output tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "numel", "ret_type": "int", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "zeros_like", "ret_type": "Tensor", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned Tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "ones", "ret_type": "Tensor", "signature": {"size": {"description": "a sequence of integers defining the shape of the output tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword arguments"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword arguments"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword arguments"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "ones_like", "ret_type": "Tensor", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned Tensor.", "type": "Keyword arguments"}, "layout": {"description": "the desired layout of returned tensor.", "type": "Keyword arguments"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword arguments"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword arguments"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "ormqr", "ret_type": "Tensor", "signature": {"input": {"description": "tensor of shape `(*, mn, k)` where `*` is zero or more batch dimensions", "type": "Args"}, "tau": {"description": "tensor of shape `(*, min(mn, k))` where `*` is zero or more batch dimensions.", "type": "Args"}, "other": {"description": "tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions.", "type": "Args"}, "left": {"description": "controls the order of multiplication.", "type": "Args"}, "transpose": {"description": "controls whether the matrix `Q` is conjugate transposed or not.", "type": "Args"}, "out": {"description": "the output Tensor. Ignored if `None`.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "outer", "ret_type": "Tensor", "signature": {"input": {"description": "1-D input vector", "type": "Args"}, "vec2": {"description": "1-D input vector", "type": "Args"}, "out": {"description": "optional output matrix", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "pca_lowrank", "ret_type": null, "signature": {"A": {"description": "the input tensor of size :math:`(*, m, n)`", "type": "Args"}, "q": {"description": "a slightly overestimated rank of", "type": "Args"}, "center": {"description": "if True, center the input tensor,", "type": "Args"}, "niter": {"description": "the number of subspace iterations to", "type": "Args"}, "structure": {"description": "probabilistic algorithms for", "type": "Args"}}, "module": "torch"}, {"func_name": "pdist", "ret_type": "Tensor", "signature": {"input": {"description": "input tensor of shape :math:`N \\times M`.", "type": "Args"}, "p": {"description": "p value for the p-norm distance to calculate between each vector pair", "type": "Args"}}, "module": "torch"}, {"func_name": "permute", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dims": {"description": "The desired ordering of dimensions", "type": "Args"}}, "module": "torch"}, {"func_name": "pixel_shuffle", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor", "type": "Args"}, "upscale_factor": {"description": "factor to increase spatial resolution by", "type": "Args"}}, "module": "torch"}, {"func_name": "pixel_unshuffle", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor", "type": "Args"}, "downscale_factor": {"description": "factor to increase spatial resolution by", "type": "Args"}}, "module": "torch"}, {"func_name": "poisson", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor containing the rates of the Poisson distribution", "type": "Args"}, "generator": {"description": "a pseudorandom number generator for sampling", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "polar", "ret_type": "Tensor", "signature": {"abs": {"description": "The absolute value the complex tensor. Must be float or double.", "type": "Args"}, "angle": {"description": "The angle of the complex tensor. Must be same dtype as", "type": "Args"}, "out": {"description": "If the inputs are ``torch.float32``, must be", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "positive", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "pow", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "exponent": {"description": "the exponent tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "self": {"description": "the scalar base value for the power operation", "type": "Args"}}, "module": "torch"}, {"func_name": "prod", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}}, "module": "torch"}, {"func_name": "qr", "ret_type": "(Tensor, Tensor)", "signature": {"input": {"description": "the input tensor of size :math:`(*, m, n)` where `*` is zero or more", "type": "Args"}, "some": {"description": "Set to ``True`` for reduced QR decomposition and ``False`` for", "type": "Args"}, "*": {"description": "returns `(Q, R)` with dimensions (m, m), (m, n)", "type": "Args"}, "out": {"description": "tuple of `Q` and `R` tensors.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "quantile", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "q": {"description": "a scalar or 1D tensor of values in the range [0, 1].", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "interpolation": {"description": "interpolation method to use when the desired quantile lies between two data points.", "type": "Keyword arguments"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "quantize_per_channel", "ret_type": "Tensor", "signature": {"input": {"description": "float tensor to quantize", "type": "Arguments"}, "scales": {"description": "float 1D tensor of scales to use, size should match ``input.size(axis)``", "type": "Arguments"}, "zero_points": {"description": "integer 1D tensor of offset to use, size should match ``input.size(axis)``", "type": "Arguments"}, "axis": {"description": "dimension on which apply per-channel quantization", "type": "Arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Arguments"}, "Has": {"description": "``torch.quint8``, ``torch.qint8``, ``torch.qint32``", "type": "Arguments"}}, "module": "torch"}, {"func_name": "quantize_per_tensor", "ret_type": "Tensor", "signature": {"input": {"description": "float tensor or list of tensors to quantize", "type": "Arguments"}, "scale": {"description": "scale to apply in quantization formula", "type": "Arguments"}, "zero_point": {"description": "offset in integer value that maps to float zero", "type": "Arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Arguments"}, "Has": {"description": "``torch.quint8``, ``torch.qint8``, ``torch.qint32``", "type": "Arguments"}}, "module": "torch"}, {"func_name": "quantize_per_tensor_dynamic", "ret_type": "Tensor", "signature": {"input": {"description": "float tensor or list of tensors to quantize", "type": "Arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Arguments"}, "Has": {"description": "``torch.quint8``, ``torch.qint8``", "type": "Arguments"}, "reduce_range": {"description": "a flag to indicate whether to reduce the range of quantized", "type": "Arguments"}}, "module": "torch"}, {"func_name": "quantized_batch_norm", "ret_type": "Tensor", "signature": {"input": {"description": "quantized tensor", "type": "Arguments"}, "weight": {"description": "float tensor that corresponds to the gamma, size C", "type": "Arguments"}, "bias": {"description": "float tensor that corresponds to the beta, size C", "type": "Arguments"}, "mean": {"description": "float mean value in batch normalization, size C", "type": "Arguments"}, "var": {"description": "float tensor for variance, size C", "type": "Arguments"}, "eps": {"description": "a value added to the denominator for numerical stability.", "type": "Arguments"}, "output_scale": {"description": "output quantized tensor scale", "type": "Arguments"}, "output_zero_point": {"description": "output quantized tensor zero_point", "type": "Arguments"}}, "module": "torch"}, {"func_name": "quantized_max_pool1d", "ret_type": "Tensor", "signature": {"input": {"description": "quantized tensor", "type": "Arguments"}, "kernel_size": {"description": "the size of the sliding window", "type": "Arguments"}, "stride": {"description": "the stride of the sliding window", "type": "Arguments"}, "padding": {"description": "padding to be added on both sides, must be >= 0 and <= kernel_size / 2", "type": "Arguments"}, "dilation": {"description": "The stride between elements within a sliding window, must be > 0. Default 1", "type": "Arguments"}, "ceil_mode": {"description": "If True, will use ceil instead of floor to compute the output shape.", "type": "Arguments"}}, "module": "torch"}, {"func_name": "quantized_max_pool2d", "ret_type": "Tensor", "signature": {"input": {"description": "quantized tensor", "type": "Arguments"}, "kernel_size": {"description": "the size of the sliding window", "type": "Arguments"}, "stride": {"description": "the stride of the sliding window", "type": "Arguments"}, "padding": {"description": "padding to be added on both sides, must be >= 0 and <= kernel_size / 2", "type": "Arguments"}, "dilation": {"description": "The stride between elements within a sliding window, must be > 0. Default 1", "type": "Arguments"}, "ceil_mode": {"description": "If True, will use ceil instead of floor to compute the output shape.", "type": "Arguments"}}, "module": "torch"}, {"func_name": "rad2deg", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "rand", "ret_type": "Tensor", "signature": {"size": {"description": "a sequence of integers defining the shape of the output tensor.", "type": "Args"}, "generator": {"description": "a pseudorandom number generator for sampling", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "rand_like", "ret_type": "Tensor", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned Tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "randint", "ret_type": "Tensor", "signature": {"low": {"description": "Lowest integer to be drawn from the distribution.", "type": "Args"}, "high": {"description": "One above the highest integer to be drawn from the distribution.", "type": "Args"}, "size": {"description": "a tuple defining the shape of the output tensor.", "type": "Args"}, "generator": {"description": "a pseudorandom number generator for sampling", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "randint_like", "ret_type": "Tensor", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "low": {"description": "Lowest integer to be drawn from the distribution.", "type": "Args"}, "high": {"description": "One above the highest integer to be drawn from the distribution.", "type": "Args"}, "dtype": {"description": "the desired data type of returned Tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "randn", "ret_type": "Tensor", "signature": {"size": {"description": "a sequence of integers defining the shape of the output tensor.", "type": "Args"}, "generator": {"description": "a pseudorandom number generator for sampling", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "randn_like", "ret_type": "Tensor", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned Tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "randperm", "ret_type": "Tensor", "signature": {"n": {"description": "the upper bound (exclusive)", "type": "Args"}, "generator": {"description": "a pseudorandom number generator for sampling", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "range", "ret_type": "Tensor", "signature": {"start": {"description": "the starting value for the set of points.", "type": "Args"}, "end": {"description": "the ending value for the set of points", "type": "Args"}, "step": {"description": "the gap between each pair of adjacent points.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "ravel", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "real", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "reciprocal", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "remainder", "ret_type": "Tensor", "signature": {"input": {"description": "the dividend", "type": "Args"}, "other": {"description": "the divisor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "renorm", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "p": {"description": "the power for the norm computation", "type": "Args"}, "dim": {"description": "the dimension to slice over to get the sub-tensors", "type": "Args"}, "maxnorm": {"description": "the maximum norm to keep each sub-tensor under", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "repeat_interleave", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "repeats": {"description": "The number of repetitions for each element.", "type": "Args"}, "dim": {"description": "The dimension along which to repeat values.", "type": "Args"}, "output_size": {"description": "Total output size for the given axis", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "reshape", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to be reshaped", "type": "Args"}, "shape": {"description": "the new shape", "type": "Args"}}, "module": "torch"}, {"func_name": "resolve_conj", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "resolve_neg", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "result_type", "ret_type": "dtype", "signature": {"tensor1": {"description": "an input tensor or number", "type": "Args"}, "tensor2": {"description": "an input tensor or number", "type": "Args"}}, "module": "torch"}, {"func_name": "roll", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "shifts": {"description": "The number of places by which the elements", "type": "Args"}, "dims": {"description": "Axis along which to roll", "type": "Args"}}, "module": "torch"}, {"func_name": "rot90", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "k": {"description": "number of times to rotate. Default value is 1", "type": "Args"}, "dims": {"description": "axis to rotate. Default value is [0, 1]", "type": "Args"}}, "module": "torch"}, {"func_name": "round", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "rsqrt", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "save", "ret_type": null, "signature": {"obj": {"description": "saved object", "type": "Args"}, "f": {"description": "a file-like object (has to implement write and flush) or a string or", "type": "Args"}, "pickle_module": {"description": "module used for pickling metadata and objects", "type": "Args"}, "pickle_protocol": {"description": "can be specified to override the default protocol", "type": "Args"}, ">>>": {"description": "+SKIP(\"makes cwd dirty\")", "type": "Args"}}, "module": "torch"}, {"func_name": "searchsorted", "ret_type": "Tensor", "signature": {"sorted_sequence": {"description": "N-D or 1-D tensor, containing monotonically increasing sequence on the *innermost*", "type": "Args"}, "values": {"description": "N-D tensor or a Scalar containing the search value(s).", "type": "Args"}, "out_int32": {"description": "indicate the output data type. torch.int32 if True, torch.int64 otherwise.", "type": "Keyword args"}, "right": {"description": "if False, return the first suitable location that is found. If True, return the", "type": "Keyword args"}, "side": {"description": "the same as :attr:`right` but preferred. \"left\" corresponds to False for :attr:`right`", "type": "Keyword args"}, "out": {"description": "the output tensor, must be the same size as :attr:`values` if provided.", "type": "Keyword args"}, "sorter": {"description": "if provided, a tensor matching the shape of the unsorted", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "select", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to slice", "type": "Args"}, "index": {"description": "the index to select with", "type": "Args"}}, "module": "torch"}, {"func_name": "select_scatter", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "src": {"description": "The tensor to embed into :attr:`input`", "type": "Args"}, "dim": {"description": "the dimension to insert the slice into.", "type": "Args"}, "index": {"description": "the index to select with", "type": "Args"}}, "module": "torch"}, {"func_name": "set_default_device", "ret_type": null, "signature": {"device": {"description": "the device to set as default", "type": "Args"}}, "module": "torch"}, {"func_name": "set_default_dtype", "ret_type": null, "signature": {"d": {"description": "the floating point dtype to make the default.", "type": "Args"}, ">>>": {"description": "+SKIP(\"Other tests may have changed the default type. Can we reset it?\")", "type": "Args"}}, "module": "torch"}, {"func_name": "set_default_tensor_type", "ret_type": null, "signature": {"t": {"description": "the floating point tensor type or its name", "type": "Args"}}, "module": "torch"}, {"func_name": "set_deterministic_debug_mode", "ret_type": null, "signature": {"debug_mode": {"description": "If \"default\" or 0, don't error or warn on", "type": "Args"}}, "module": "torch"}, {"func_name": "set_float32_matmul_precision", "ret_type": null, "signature": {"precision": {"description": "can be set to \"highest\" (default), \"high\", or \"medium\" (see above).", "type": "Args"}}, "module": "torch"}, {"func_name": "set_flush_denormal", "ret_type": "bool", "signature": {"mode": {"description": "Controls whether to enable flush denormal mode or not", "type": "Args"}}, "module": "torch"}, {"func_name": "set_grad_enabled", "ret_type": null, "signature": {"mode": {"description": "Flag whether to enable grad (``True``), or disable", "type": "Args"}}, "module": "torch"}, {"func_name": "set_printoptions", "ret_type": null, "signature": {"precision": {"description": "Number of digits of precision for floating point output", "type": "Args"}, "threshold": {"description": "Total number of array elements which trigger summarization", "type": "Args"}, "edgeitems": {"description": "Number of array items in summary at beginning and end of", "type": "Args"}, "linewidth": {"description": "The number of characters per line for the purpose of", "type": "Args"}, "profile": {"description": "Sane defaults for pretty printing. Can override with any of", "type": "Args"}, "sci_mode": {"description": "Enable (True) or disable (False) scientific notation. If", "type": "Args"}}, "module": "torch"}, {"func_name": "set_rng_state", "ret_type": null, "signature": {"new_state": {"description": "The desired state", "type": "Args"}}, "module": "torch"}, {"func_name": "set_warn_always", "ret_type": null, "signature": {"b": {"description": "If True, force warnings to always be emitted", "type": "Args"}}, "module": "torch"}, {"func_name": "sgn", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "sign", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "signbit", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "sin", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "sinh", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "slice_scatter", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "src": {"description": "The tensor to embed into :attr:`input`", "type": "Args"}, "dim": {"description": "the dimension to insert the slice into", "type": "Args"}, "start": {"description": "the start index of where to insert the slice", "type": "Args"}, "end": {"description": "the end index of where to insert the slice", "type": "Args"}, "step": {"description": "the how many elements to skip in", "type": "Args"}}, "module": "torch"}, {"func_name": "smm", "ret_type": "Tensor", "signature": {"input": {"description": "a sparse matrix to be matrix multiplied", "type": "Args"}}, "module": "torch"}, {"func_name": "sort", "ret_type": "(Tensor, LongTensor)", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to sort along", "type": "Args"}, "descending": {"description": "controls the sorting order (ascending or descending)", "type": "Args"}, "stable": {"description": "makes the sorting routine stable, which guarantees that the order", "type": "Args"}, "out": {"description": "the output tuple of (`Tensor`, `LongTensor`) that can", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "sparse_bsc_tensor", "ret_type": "Tensor", "signature": {"ccol_indices": {"description": "(B+1)-dimensional array of size", "type": "Args"}, "row_indices": {"description": "Row block co-ordinates of each block in", "type": "Args"}, "values": {"description": "Initial blocks for the tensor. Can be a list,", "type": "Args"}, "size": {"description": "Size of the", "type": "Args"}, "sparse": {"description": "``(*batchsize, nrows * blocksize[0], ncols *", "type": "Args"}, "dtype": {"description": "the desired data type of", "type": "Keyword args"}, "device": {"description": "the desired device of", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "sparse_bsr_tensor", "ret_type": "Tensor", "signature": {"crow_indices": {"description": "(B+1)-dimensional array of size", "type": "Args"}, "col_indices": {"description": "Column block co-ordinates of each block", "type": "Args"}, "values": {"description": "Initial values for the tensor. Can be a list,", "type": "Args"}, "size": {"description": "Size of the", "type": "Args"}, "sparse": {"description": "``(*batchsize, nrows * blocksize[0], ncols *", "type": "Args"}, "dtype": {"description": "the desired data type of", "type": "Keyword args"}, "device": {"description": "the desired device of", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "sparse_compressed_tensor", "ret_type": "Tensor", "signature": {"compressed_indices": {"description": "(B+1)-dimensional array of size", "type": "Args"}, "plain_indices": {"description": "Plain dimension (column or row)", "type": "Args"}, "values": {"description": "Initial values for the tensor. Can be a list,", "type": "Args"}, "size": {"description": "Size of the", "type": "Args"}, "sparse": {"description": "``(*batchsize, nrows * blocksize[0], ncols *", "type": "Args"}, "dtype": {"description": "the desired data type of", "type": "Keyword args"}, "layout": {"description": "the desired layout of", "type": "Keyword args"}, "returned": {"description": ":attr:`torch.sparse_csr`,", "type": "Keyword args"}, "device": {"description": "the desired device of", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "sparse_coo_tensor", "ret_type": "Tensor", "signature": {"indices": {"description": "Initial data for the tensor. Can be a list, tuple,", "type": "Args"}, "values": {"description": "Initial values for the tensor. Can be a list, tuple,", "type": "Args"}, "size": {"description": "Size of the sparse tensor. If not", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}, "is_coalesced": {"description": "When``True``, the caller is", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "sparse_csc_tensor", "ret_type": "Tensor", "signature": {"ccol_indices": {"description": "(B+1)-dimensional array of size", "type": "Args"}, "row_indices": {"description": "Row co-ordinates of each element in", "type": "Args"}, "values": {"description": "Initial values for the tensor. Can be a list,", "type": "Args"}, "size": {"description": "Size of the", "type": "Args"}, "sparse": {"description": "``(*batchsize, nrows, ncols, *densesize)``. If", "type": "Args"}, "dtype": {"description": "the desired data type of", "type": "Keyword args"}, "device": {"description": "the desired device of", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "sparse_csr_tensor", "ret_type": "Tensor", "signature": {"crow_indices": {"description": "(B+1)-dimensional array of size", "type": "Args"}, "col_indices": {"description": "Column co-ordinates of each element in", "type": "Args"}, "values": {"description": "Initial values for the tensor. Can be a list,", "type": "Args"}, "size": {"description": "Size of the", "type": "Args"}, "sparse": {"description": "``(*batchsize, nrows, ncols, *densesize)``. If", "type": "Args"}, "dtype": {"description": "the desired data type of", "type": "Keyword args"}, "device": {"description": "the desired device of", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "split", "ret_type": null, "signature": {"tensor": {"description": "tensor to split.", "type": "Args"}, "split_size_or_sections": {"description": "size of a single chunk or", "type": "Args"}, "dim": {"description": "dimension along which to split the tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "sqrt", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "square", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "squeeze", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "if given, the input will be squeezed", "type": "Args"}, "..": {"description": "2.0", "type": "Args"}}, "module": "torch"}, {"func_name": "sspaddmm", "ret_type": "Tensor", "signature": {"input": {"description": "a sparse matrix to be added", "type": "Args"}, "mat1": {"description": "a sparse matrix to be matrix multiplied", "type": "Args"}, "mat2": {"description": "a dense matrix to be matrix multiplied", "type": "Args"}, "beta": {"description": "multiplier for :attr:`mat` (:math:`\\beta`)", "type": "Keyword args"}, "alpha": {"description": "multiplier for :math:`mat1 @ mat2` (:math:`\\alpha`)", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "stack", "ret_type": "Tensor", "signature": {"tensors": {"description": "sequence of tensors to concatenate", "type": "Arguments"}, "dim": {"description": "dimension to insert. Has to be between 0 and the number", "type": "Arguments"}}, "module": "torch"}, {"func_name": "std", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "correction": {"description": "difference between the sample size and sample degrees of freedom.", "type": "Keyword args"}, "..": {"description": "https://en.wikipedia.org/wiki/Bessel%27s_correction", "type": "Keyword args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "std_mean", "ret_type": "(Tensor, Tensor)", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "correction": {"description": "difference between the sample size and sample degrees of freedom.", "type": "Keyword args"}, "..": {"description": "2.0", "type": "Keyword args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "stft", "ret_type": null, "signature": {"input": {"description": "the input tensor of shape `(B?, L)` where `B?` is an optional", "type": "Args"}, "n_fft": {"description": "size of Fourier transform", "type": "Args"}, "hop_length": {"description": "the distance between neighboring sliding window", "type": "Args"}, "win_length": {"description": "the size of window frame and STFT filter.", "type": "Args"}, "window": {"description": "the optional window function.", "type": "Args"}, "center": {"description": "whether to pad :attr:`input` on both sides so", "type": "Args"}, "pad_mode": {"description": "controls the padding method used when", "type": "Args"}, "normalized": {"description": "controls whether to return the normalized STFT results", "type": "Args"}, "onesided": {"description": "controls whether to return half of results to", "type": "Args"}, "return_complex": {"description": "whether to return a complex tensor, or", "type": "Args"}, "..": {"description": "2.0", "type": "Args"}}, "module": "torch"}, {"func_name": "sub", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the tensor or number to subtract from :attr:`input`.", "type": "Args"}, "alpha": {"description": "the multiplier for :attr:`other`.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "sum", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}}, "module": "torch"}, {"func_name": "svd", "ret_type": "(Tensor, Tensor, Tensor)", "signature": {"input": {"description": "the input tensor of size `(*, m, n)` where `*` is zero or more", "type": "Args"}, "some": {"description": "controls whether to compute the reduced or full decomposition, and", "type": "Args"}, "compute_uv": {"description": "controls whether to compute `U` and `V`.", "type": "Args"}, "out": {"description": "the output tuple of tensors", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "svd_lowrank", "ret_type": null, "signature": {"A": {"description": "the input tensor of size :math:`(*, m, n)`", "type": "Args"}, "q": {"description": "a slightly overestimated rank of A.", "type": "Args"}, "niter": {"description": "the number of subspace iterations to", "type": "Args"}, "M": {"description": "the input tensor's mean of size", "type": "Args"}, "structure": {"description": "probabilistic algorithms for", "type": "Args"}}, "module": "torch"}, {"func_name": "sym_float", "ret_type": null, "signature": {"a": {"description": "Object to cast", "type": "Args"}}, "module": "torch"}, {"func_name": "sym_int", "ret_type": null, "signature": {"a": {"description": "Object to cast", "type": "Args"}}, "module": "torch"}, {"func_name": "sym_not", "ret_type": null, "signature": {"a": {"description": "Object to negate", "type": "Args"}}, "module": "torch"}, {"func_name": "t", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "take", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "index": {"description": "the indices into tensor", "type": "Args"}}, "module": "torch"}, {"func_name": "take_along_dim", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "indices": {"description": "the indices into :attr:`input`. Must have long dtype.", "type": "Args"}, "dim": {"description": "dimension to select along.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "tan", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "tanh", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "tensor", "ret_type": "Tensor", "signature": {"data": {"description": "Initial data for the tensor. Can be a list, tuple,", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "device": {"description": "the device of the constructed tensor. If None and data is a tensor", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "tensor_split", "ret_type": "List of Tensors", "signature": {"input": {"description": "the tensor to split", "type": "Args"}, "indices_or_sections": {"description": "", "type": "Args"}, "dim": {"description": "dimension along which to split the tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "tensordot", "ret_type": null, "signature": {"a": {"description": "Left tensor to contract", "type": "Args"}, "b": {"description": "Right tensor to contract", "type": "Args"}, "dims": {"description": "number of dimensions to", "type": "Args"}, ">>>": {"description": "+REQUIRES(env:TORCH_DOCTEST_CUDA)", "type": "Args"}}, "module": "torch"}, {"func_name": "tile", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor whose elements to repeat.", "type": "Args"}, "dims": {"description": "the number of repetitions per dimension.", "type": "Args"}}, "module": "torch"}, {"func_name": "_to_dlpack", "ret_type": "PyCapsule", "signature": {"tensor": {"description": "a tensor to be exported", "type": "Args"}}, "module": "torch"}, {"func_name": "topk", "ret_type": "(Tensor, LongTensor)", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "k": {"description": "the k in \"top-k\"", "type": "Args"}, "dim": {"description": "the dimension to sort along", "type": "Args"}, "largest": {"description": "controls whether to return largest or", "type": "Args"}, "sorted": {"description": "controls whether to return the elements", "type": "Args"}, "out": {"description": "the output tuple of (Tensor, LongTensor) that can be", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "transpose", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim0": {"description": "the first dimension to be transposed", "type": "Args"}, "dim1": {"description": "the second dimension to be transposed", "type": "Args"}}, "module": "torch"}, {"func_name": "trapezoid", "ret_type": "Tensor", "signature": {"y": {"description": "Values to use when computing the trapezoidal rule.", "type": "Arguments"}, "x": {"description": "If specified, defines spacing between values as specified above.", "type": "Arguments"}, "dx": {"description": "constant spacing between values. If neither :attr:`x` or :attr:`dx`", "type": "Keyword arguments"}, "dim": {"description": "The dimension along which to compute the trapezoidal rule.", "type": "Keyword arguments"}, ">>>": {"description": "the result is the same as before, but multiplied by 2", "type": "Keyword arguments"}}, "module": "torch"}, {"func_name": "triangular_solve", "ret_type": "(Tensor, Tensor)", "signature": {"b": {"description": "multiple right-hand sides of size :math:`(*, m, k)` where", "type": "Args"}, "A": {"description": "the input triangular coefficient matrix of size :math:`(*, m, m)`", "type": "Args"}, "upper": {"description": "whether :math:`A` is upper or lower triangular.", "type": "Args"}, "transpose": {"description": "solves `op(A)X = b` where `op(A) = A^T` if this flag is ``True``,", "type": "Args"}, "unitriangular": {"description": "whether :math:`A` is unit triangular.", "type": "Args"}, "out": {"description": "tuple of two tensors to write", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "tril", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "diagonal": {"description": "the diagonal to consider", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "tril_indices", "ret_type": "Tensor", "signature": {"row": {"description": "number of rows in the 2-D matrix.", "type": "Args"}, "col": {"description": "number of columns in the 2-D matrix.", "type": "Args"}, "offset": {"description": "diagonal offset from the main diagonal.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "layout": {"description": "currently only support ``torch.strided``.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "triu", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "diagonal": {"description": "the diagonal to consider", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "triu_indices", "ret_type": "Tensor", "signature": {"row": {"description": "number of rows in the 2-D matrix.", "type": "Args"}, "col": {"description": "number of columns in the 2-D matrix.", "type": "Args"}, "offset": {"description": "diagonal offset from the main diagonal.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "layout": {"description": "currently only support ``torch.strided``.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "trunc", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "unbind", "ret_type": "seq", "signature": {"input": {"description": "the tensor to unbind", "type": "Arguments"}, "dim": {"description": "dimension to remove", "type": "Arguments"}}, "module": "torch"}, {"func_name": "unflatten", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "Dimension to be unflattened, specified as an index into", "type": "Args"}, "sizes": {"description": "New shape of the unflattened dimension.", "type": "Args"}}, "module": "torch"}, {"func_name": "unique", "ret_type": "Tuple[Tensor, Tensor, Tensor]", "signature": {"input": {"description": "the input tensor", "type": "Args"}, "sorted": {"description": "Whether to sort the unique elements in ascending order", "type": "Args"}, "return_inverse": {"description": "Whether to also return the indices for where", "type": "Args"}, "return_counts": {"description": "Whether to also return the counts for each unique", "type": "Args"}, "dim": {"description": "the dimension to operate upon. If ``None``, the", "type": "Args"}}, "module": "torch"}, {"func_name": "unique_consecutive", "ret_type": null, "signature": {"input": {"description": "the input tensor", "type": "Args"}, "return_inverse": {"description": "Whether to also return the indices for where", "type": "Args"}, "return_counts": {"description": "Whether to also return the counts for each unique", "type": "Args"}, "dim": {"description": "the dimension to apply unique. If ``None``, the unique of the", "type": "Args"}, "flattened": {"description": "``None``", "type": "Args"}}, "module": "torch"}, {"func_name": "unsqueeze", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the index at which to insert the singleton dimension", "type": "Args"}}, "module": "torch"}, {"func_name": "use_deterministic_algorithms", "ret_type": null, "signature": {"mode": {"description": "If True, makes potentially nondeterministic", "type": "Args"}, "warn_only": {"description": "If True, operations that do not", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "vander", "ret_type": "Tensor", "signature": {"x": {"description": "1-D input tensor.", "type": "Arguments"}, "N": {"description": "Number of columns in the output. If N is not specified,", "type": "Arguments"}, "increasing": {"description": "Order of the powers of the columns. If True,", "type": "Arguments"}}, "module": "torch"}, {"func_name": "var", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "correction": {"description": "difference between the sample size and sample degrees of freedom.", "type": "Keyword args"}, "..": {"description": "https://en.wikipedia.org/wiki/Bessel%27s_correction", "type": "Keyword args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "var_mean", "ret_type": "(Tensor, Tensor)", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "correction": {"description": "difference between the sample size and sample degrees of freedom.", "type": "Keyword args"}, "..": {"description": "2.0", "type": "Keyword args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "vdot", "ret_type": "Tensor", "signature": {"input": {"description": "first tensor in the dot product, must be 1D. Its conjugate is used if it's complex.", "type": "Args"}, "other": {"description": "second tensor in the dot product, must be 1D.", "type": "Args"}}, "module": "torch"}, {"func_name": "view_as_complex", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "view_as_real", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}, "module": "torch"}, {"func_name": "vmap", "ret_type": null, "signature": {"func": {"description": "A Python function that takes one or more arguments.", "type": "Args"}, "in_dims": {"description": "Specifies which dimension of the", "type": "Args"}, "out_dims": {"description": "Specifies where the mapped dimension", "type": "Args"}, "randomness": {"description": "Specifies whether the randomness in this", "type": "Args"}, "chunk_size": {"description": "If None (default), apply a single vmap over inputs.", "type": "Args"}}, "module": "torch"}, {"func_name": "vsplit", "ret_type": "List of Tensors", "signature": {"input": {"description": "tensor to split.", "type": "Args"}, "indices_or_sections": {"description": "See argument in :func:`torch.tensor_split`.", "type": "Args"}}, "module": "torch"}, {"func_name": "vstack", "ret_type": "Tensor", "signature": {"tensors": {"description": "sequence of tensors to concatenate", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "where", "ret_type": "Tensor", "signature": {"condition": {"description": "When True (nonzero), yield input, otherwise yield other", "type": "Arguments"}, "input": {"description": "value (if :attr:`input` is a scalar) or values selected at indices", "type": "Arguments"}, "other": {"description": "value (if :attr:`other` is a scalar) or values selected at indices", "type": "Arguments"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "zeros", "ret_type": "Tensor", "signature": {"size": {"description": "a sequence of integers defining the shape of the output tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "zeros_like", "ret_type": "Tensor", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned Tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword args"}}, "module": "torch"}, {"func_name": "__contains__", "ret_type": null, "signature": {"element": {"description": "element to be checked", "type": "Args"}}, "module": "Tensor"}, {"func_name": "__dlpack__", "ret_type": null, "signature": {"stream": {"description": "An optional Python integer representing a", "type": "Args"}}, "module": "Tensor"}, {"func_name": "align_to", "ret_type": null, "signature": {"names": {"description": "The desired dimension ordering of the", "type": "Args"}}, "module": "Tensor"}, {"func_name": "backward", "ret_type": null, "signature": {"gradient": {"description": "Gradient w.r.t. the", "type": "Args"}, "retain_graph": {"description": "If ``False``, the graph used to compute", "type": "Args"}, "create_graph": {"description": "If ``True``, graph of the derivative will", "type": "Args"}, "inputs": {"description": "Inputs w.r.t. which the gradient will be", "type": "Args"}}, "module": "Tensor"}, {"func_name": "bfloat16", "ret_type": null, "signature": {"memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "bool", "ret_type": "Tensor", "signature": {"memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "byte", "ret_type": "Tensor", "signature": {"memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "cdouble", "ret_type": "Tensor", "signature": {"memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "cfloat", "ret_type": "Tensor", "signature": {"memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "chalf", "ret_type": "Tensor", "signature": {"memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "char", "ret_type": "Tensor", "signature": {"memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "contiguous", "ret_type": "Tensor", "signature": {"memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "copy_", "ret_type": "Tensor", "signature": {"src": {"description": "the source tensor to copy from", "type": "Args"}, "non_blocking": {"description": "if ``True`` and this copy is between CPU and GPU,", "type": "Args"}}, "module": "Tensor"}, {"func_name": "cpu", "ret_type": "Tensor", "signature": {"memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "cuda", "ret_type": "Tensor", "signature": {"device": {"description": "The destination GPU device.", "type": "Args"}, "non_blocking": {"description": "If ``True`` and the source is in pinned memory,", "type": "Args"}, "memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "double", "ret_type": "Tensor", "signature": {"memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "expand", "ret_type": "Tensor", "signature": {"*sizes": {"description": "the desired expanded size", "type": "Args"}}, "module": "Tensor"}, {"func_name": "expand_as", "ret_type": "Tensor", "signature": {"other": {"description": "The result tensor has the same size", "type": "Args"}}, "module": "Tensor"}, {"func_name": "fill_diagonal_", "ret_type": "Tensor", "signature": {"fill_value": {"description": "the fill value", "type": "Arguments"}, "wrap": {"description": "the diagonal 'wrapped' after N columns for tall matrices.", "type": "Arguments"}}, "module": "Tensor"}, {"func_name": "float", "ret_type": "Tensor", "signature": {"memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "half", "ret_type": "Tensor", "signature": {"memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "index_add_", "ret_type": "Tensor", "signature": {"dim": {"description": "dimension along which to index", "type": "Args"}, "index": {"description": "indices of ``source`` to select from,", "type": "Args"}, "source": {"description": "the tensor containing values to add", "type": "Args"}, "alpha": {"description": "the scalar multiplier for ``source``", "type": "Keyword args"}}, "module": "Tensor"}, {"func_name": "index_copy_", "ret_type": "Tensor", "signature": {"dim": {"description": "dimension along which to index", "type": "Args"}, "index": {"description": "indices of :attr:`tensor` to select from", "type": "Args"}, "tensor": {"description": "the tensor containing values to copy", "type": "Args"}}, "module": "Tensor"}, {"func_name": "index_fill_", "ret_type": "Tensor", "signature": {"dim": {"description": "dimension along which to index", "type": "Args"}, "index": {"description": "indices of :attr:`self` tensor to fill in", "type": "Args"}, "value": {"description": "the value to fill with", "type": "Args"}}, "module": "Tensor"}, {"func_name": "index_put_", "ret_type": "Tensor", "signature": {"indices": {"description": "tensors used to index into `self`.", "type": "Args"}, "values": {"description": "tensor of same dtype as `self`.", "type": "Args"}}, "module": "Tensor"}, {"func_name": "index_reduce_", "ret_type": "Tensor", "signature": {"dim": {"description": "dimension along which to index", "type": "Args"}, "index": {"description": "indices of ``source`` to select from,", "type": "Args"}, "source": {"description": "the tensor containing values to accumulate", "type": "Args"}, "reduce": {"description": "the reduction operation to apply", "type": "Args"}, "include_self": {"description": "whether the elements from the ``self`` tensor are", "type": "Keyword args"}}, "module": "Tensor"}, {"func_name": "int", "ret_type": "Tensor", "signature": {"memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "ipu", "ret_type": "Tensor", "signature": {"device": {"description": "The destination IPU device.", "type": "Args"}, "non_blocking": {"description": "If ``True`` and the source is in pinned memory,", "type": "Args"}, "memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "is_contiguous", "ret_type": "bool", "signature": {"memory_format": {"description": "Specifies memory allocation", "type": "Args"}}, "module": "Tensor"}, {"func_name": "long", "ret_type": "Tensor", "signature": {"memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "masked_fill_", "ret_type": null, "signature": {"mask": {"description": "the boolean mask", "type": "Args"}}, "module": "Tensor"}, {"func_name": "masked_scatter_", "ret_type": null, "signature": {"mask": {"description": "the boolean mask", "type": "Args"}, "source": {"description": "the tensor to copy from", "type": "Args"}}, "module": "Tensor"}, {"func_name": "new_empty", "ret_type": "Tensor", "signature": {"size": {"description": "a list, tuple, or :class:`torch.Size` of integers defining the", "type": "Args"}, "dtype": {"description": "the desired type of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}, "module": "Tensor"}, {"func_name": "new_empty_strided", "ret_type": "Tensor", "signature": {"size": {"description": "a list, tuple, or :class:`torch.Size` of integers defining the", "type": "Args"}, "dtype": {"description": "the desired type of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}, "module": "Tensor"}, {"func_name": "new_full", "ret_type": "Tensor", "signature": {"fill_value": {"description": "the number to fill the output tensor with.", "type": "Args"}, "dtype": {"description": "the desired type of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}, "module": "Tensor"}, {"func_name": "new_ones", "ret_type": "Tensor", "signature": {"size": {"description": "a list, tuple, or :class:`torch.Size` of integers defining the", "type": "Args"}, "dtype": {"description": "the desired type of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}, "module": "Tensor"}, {"func_name": "new_tensor", "ret_type": "Tensor", "signature": {"data": {"description": "The returned Tensor copies :attr:`data`.", "type": "Args"}, "dtype": {"description": "the desired type of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}, "module": "Tensor"}, {"func_name": "new_zeros", "ret_type": "Tensor", "signature": {"size": {"description": "a list, tuple, or :class:`torch.Size` of integers defining the", "type": "Args"}, "dtype": {"description": "the desired type of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}, "module": "Tensor"}, {"func_name": "nonzero_static", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor to count non-zero elements.", "type": "Args"}, "size": {"description": "the size of non-zero elements expected to be included in the out", "type": "Keyword args"}, "fill_value": {"description": "the value to fill the output tensor with when `size` is larger", "type": "Keyword args"}, "#": {"description": "0 rank input", "type": "Keyword args"}}, "module": "Tensor"}, {"func_name": "numpy", "ret_type": "numpy.ndarray", "signature": {"force": {"description": "if ``True``, the ndarray may be a copy of the tensor", "type": "Args"}}, "module": "Tensor"}, {"func_name": "put_", "ret_type": "Tensor", "signature": {"index": {"description": "the indices into self", "type": "Args"}, "source": {"description": "the tensor containing values to copy from", "type": "Args"}, "accumulate": {"description": "whether to accumulate into self", "type": "Args"}}, "module": "Tensor"}, {"func_name": "refine_names", "ret_type": null, "signature": {"names": {"description": "The desired names of the output tensor. May", "type": "Args"}}, "module": "Tensor"}, {"func_name": "repeat", "ret_type": "Tensor", "signature": {"sizes": {"description": "The number of times to repeat this tensor along each", "type": "Args"}}, "module": "Tensor"}, {"func_name": "requires_grad_", "ret_type": "Tensor", "signature": {"requires_grad": {"description": "If autograd should record operations on this tensor.", "type": "Args"}}, "module": "Tensor"}, {"func_name": "reshape", "ret_type": "Tensor", "signature": {"shape": {"description": "the desired shape", "type": "Args"}}, "module": "Tensor"}, {"func_name": "reshape_as", "ret_type": "Tensor", "signature": {"other": {"description": "The result tensor has the same shape", "type": "Args"}}, "module": "Tensor"}, {"func_name": "resize_", "ret_type": "Tensor", "signature": {"sizes": {"description": "the desired size", "type": "Args"}, "memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "resize_as_", "ret_type": "Tensor", "signature": {"memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "scatter_", "ret_type": "Tensor", "signature": {"dim": {"description": "the axis along which to index", "type": "Args"}, "index": {"description": "the indices of elements to scatter, can be either empty", "type": "Args"}, "src": {"description": "the source element(s) to scatter.", "type": "Args"}, "reduce": {"description": "reduction operation to apply, can be either", "type": "Args"}}, "module": "Tensor"}, {"func_name": "scatter_add_", "ret_type": "Tensor", "signature": {"dim": {"description": "the axis along which to index", "type": "Args"}, "index": {"description": "the indices of elements to scatter and add, can be", "type": "Args"}, "src": {"description": "the source elements to scatter and add", "type": "Args"}}, "module": "Tensor"}, {"func_name": "scatter_reduce_", "ret_type": "Tensor", "signature": {"dim": {"description": "the axis along which to index", "type": "Args"}, "index": {"description": "the indices of elements to scatter and reduce.", "type": "Args"}, "src": {"description": "the source elements to scatter and reduce", "type": "Args"}, "reduce": {"description": "the reduction operation to apply for non-unique indices", "type": "Args"}, "include_self": {"description": "whether elements from the :attr:`self` tensor are", "type": "Args"}}, "module": "Tensor"}, {"func_name": "set_", "ret_type": "Tensor", "signature": {"source": {"description": "the tensor or storage to use", "type": "Args"}, "storage_offset": {"description": "the offset in the storage", "type": "Args"}, "size": {"description": "the desired size. Defaults to the size of the source.", "type": "Args"}}, "module": "Tensor"}, {"func_name": "short", "ret_type": "Tensor", "signature": {"memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "size", "ret_type": "torch.Size or int", "signature": {"dim": {"description": "The dimension for which to retrieve the size.", "type": "Args"}}, "module": "Tensor"}, {"func_name": "sparse_mask", "ret_type": "Tensor", "signature": {"mask": {"description": "a sparse tensor whose indices are used as a filter", "type": "Args"}}, "module": "Tensor"}, {"func_name": "sparse_resize_", "ret_type": "Tensor", "signature": {"size": {"description": "the desired size. If :attr:`self` is non-empty", "type": "Args"}, "sparse_dim": {"description": "the number of sparse dimensions", "type": "Args"}}, "module": "Tensor"}, {"func_name": "sparse_resize_and_clear_", "ret_type": "Tensor", "signature": {"size": {"description": "the desired size.", "type": "Args"}, "sparse_dim": {"description": "the number of sparse dimensions", "type": "Args"}}, "module": "Tensor"}, {"func_name": "stride", "ret_type": "tuple or int", "signature": {"dim": {"description": "the desired dimension in which stride is required", "type": "Args"}}, "module": "Tensor"}, {"func_name": "to", "ret_type": "Tensor", "signature": {"memory_format": {"description": "the desired memory format of", "type": "Args"}, "..": {"description": "to(other, non_blocking=False, copy=False) -> Tensor", "type": "Args"}}, "module": "Tensor"}, {"func_name": "to_dense", "ret_type": "Tensor", "signature": {"masked_grad": {"description": "If set to ``True`` (default) and", "type": "Keyword args"}}, "module": "Tensor"}, {"func_name": "to_sparse", "ret_type": "Tensor", "signature": {"sparseDims": {"description": "the number of sparse dimensions to include in the new sparse tensor", "type": "Args"}, "layout": {"description": "The desired sparse", "type": "Args"}, "blocksize": {"description": "Block size", "type": "Args"}, "dense_dim": {"description": "Number of dense dimensions of the", "type": "Args"}}, "module": "Tensor"}, {"func_name": "to_sparse_bsc", "ret_type": "Tensor", "signature": {"blocksize": {"description": "Block size", "type": "Args"}, "dense_dim": {"description": "Number of dense dimensions of the", "type": "Args"}}, "module": "Tensor"}, {"func_name": "to_sparse_bsr", "ret_type": "Tensor", "signature": {"blocksize": {"description": "Block size", "type": "Args"}, "dense_dim": {"description": "Number of dense dimensions of the", "type": "Args"}}, "module": "Tensor"}, {"func_name": "to_sparse_csc", "ret_type": "Tensor", "signature": {"dense_dim": {"description": "Number of dense dimensions of the", "type": "Args"}}, "module": "Tensor"}, {"func_name": "to_sparse_csr", "ret_type": "Tensor", "signature": {"dense_dim": {"description": "Number of dense dimensions of the", "type": "Args"}}, "module": "Tensor"}, {"func_name": "type", "ret_type": null, "signature": {"dtype": {"description": "The desired type", "type": "Args"}, "non_blocking": {"description": "If ``True``, and the source is in pinned memory", "type": "Args"}, "**kwargs": {"description": "For compatibility, may contain the key ``async`` in place of", "type": "Args"}}, "module": "Tensor"}, {"func_name": "unfold", "ret_type": "Tensor", "signature": {"dimension": {"description": "dimension in which unfolding happens", "type": "Args"}, "size": {"description": "the size of each slice that is unfolded", "type": "Args"}, "step": {"description": "the step between each slice", "type": "Args"}}, "module": "Tensor"}, {"func_name": "view", "ret_type": "Tensor", "signature": {"shape": {"description": "the desired size", "type": "Args"}, "dtype": {"description": "the desired dtype", "type": "Args"}}, "module": "Tensor"}, {"func_name": "view_as", "ret_type": "Tensor", "signature": {"other": {"description": "The result tensor has the same size", "type": "Args"}}, "module": "Tensor"}, {"func_name": "xpu", "ret_type": "Tensor", "signature": {"device": {"description": "The destination XPU device.", "type": "Args"}, "non_blocking": {"description": "If ``True`` and the source is in pinned memory,", "type": "Args"}, "memory_format": {"description": "the desired memory format of", "type": "Args"}}, "module": "Tensor"}]